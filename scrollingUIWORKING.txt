package com.example.plaan;

import java.util.Calendar;
import java.util.LinkedList;

import android.app.Notification;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.content.Intent;
import android.os.Bundle;
import android.os.CountDownTimer;
import android.os.Handler;
import android.support.v4.app.FragmentActivity;
import android.util.Log;
import android.view.Gravity;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.Window;
import android.view.animation.Animation;
import android.view.animation.AnimationUtils;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.LinearLayout.LayoutParams;
import android.widget.RelativeLayout;
import android.widget.ScrollView;
import android.widget.TextView;

import com.example.plaan.ActivityCard.onSetClickListener;
import com.zenkun.datetimepicker.time.RadialPickerLayout;
import com.zenkun.datetimepicker.time.TimePickerDialog;
import com.zenkun.datetimepicker.time.TimePickerDialog.OnTimeSetListener;

public class ScrollingUI extends FragmentActivity implements OnClickListener,
		OnTimeSetListener {

	private int CARD_WIDTH;
	private int CARD_HEIGHT;

	ScrollView svScrollingUI;

	// SleepingCard
	RelativeLayout rlLayoutSleepingCard, rlAvailableTimeClock, rlSleepingCard,
			rlSleepingCloudGroup, rlYellowClock;
	ImageView ivAvailableTimeClock, ivBlueTimeFrame, ivSleepingCloud;
	TextView tvAvailableTime, tvSLEEP, tvSetSleepTime;

	// ActivityCard
	LinearLayout llLayoutActivityCard;
	final int AC_ID_HEADER = 224;
	int acIDCounter;
	LinkedList<ActivitiesPlaan> activitiesList;
	LinkedList<ActivityCard> activityCardList;
	ActivityCard activityCardOnFocus;
	int activitiesListIndex;
	int LAYOUT_POSITION;
	NotificationManager nm;
	final int TAG_HEADER = 276;
	int tag_counter;
	static final int notificationId = 1394885;

	// CountDown
	CountDownTimer activitiesCDT;
	private Handler mHandler = new Handler();
	private long startTime;
	private long stopTime;
	private long elapsedTime;
	private final int REFRESH_RATE = 100;

	// freeTimeCard
	private final int FTC_ID_HEADER = 457;
	int ftc_id_counter;
	LinkedList<FreeTimeCard> ftcList;

	// plus_button
	ImageView ivPlusButton;

	// start_button
	RelativeLayout rlSTARTButton;
	TextView tvSTARTButton;

	int clickedActivityType;
	public static TimePickerDialog timePickerDialog;

	float scaleDP;

	// long timeRemaining;

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		this.requestWindowFeature(Window.FEATURE_NO_TITLE);
		super.onCreate(savedInstanceState);
		setContentView(R.layout.scrolling_ui_main);

		scaleDP = getApplicationContext().getResources().getDisplayMetrics().density;
		CARD_WIDTH = (int) (300 * scaleDP + 0.5f);
		CARD_HEIGHT = (int) (375 * scaleDP + 0.5f);
		acIDCounter = 0;
		activitiesList = new LinkedList<>();
		activityCardList = new LinkedList<>();
		LAYOUT_POSITION = 0;
		ftc_id_counter = 0;
		tag_counter = 0;
		ftcList = new LinkedList<FreeTimeCard>();

		activitiesListIndex = 0;
		nm = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);

		initializeViews();
		setTypefaces();

		// sleepCard
		tvSetSleepTime.setOnClickListener(this);
		Animation comeIn = AnimationUtils.loadAnimation(
				getApplicationContext(), R.anim.down_from_top_w_alpha);
		rlSleepingCard.setAnimation(comeIn);

		// plusButton
		ivPlusButton.setOnClickListener(this);

		// startButton
		rlSTARTButton.setOnClickListener(this);

	}

	private void setTypefaces() {
		TypefacePlaan tfp = new TypefacePlaan();
		tfp.setTypeface(tvAvailableTime, TypefacePlaan.LEAGUE_GOTHIC);
		tfp.setTypeface(tvSLEEP, TypefacePlaan.OPEN_SANS_BOLD);
		tfp.setTypeface(tvSetSleepTime, TypefacePlaan.OPEN_SANS_BOLD);
		tfp.setTypeface(tvSTARTButton, TypefacePlaan.LEAGUE_GOTHIC);
	}

	private void initializeViews() {
		svScrollingUI = (ScrollView) findViewById(R.id.svScrollingUI);

		// SleepingCard
		llLayoutActivityCard = (LinearLayout) findViewById(R.id.llLayoutActivityCard);
		rlLayoutSleepingCard = (RelativeLayout) findViewById(R.id.rlLayoutSleepingCard);
		rlSleepingCard = (RelativeLayout) findViewById(R.id.rlSleepingCard);
		rlSleepingCloudGroup = (RelativeLayout) findViewById(R.id.rlSleepingCloudGroup);

		ivSleepingCloud = (ImageView) findViewById(R.id.ivSleepingCloud);
		tvSLEEP = (TextView) findViewById(R.id.tvSLEEP);
		tvSetSleepTime = (TextView) findViewById(R.id.tvSetSleepTime);
		tvAvailableTime = (TextView) findViewById(R.id.tvAvailableTime);

		// plusButton
		ivPlusButton = (ImageView) findViewById(R.id.ivPlusButton);

		// startButton
		rlSTARTButton = (RelativeLayout) findViewById(R.id.rlStartButton);
		tvSTARTButton = (TextView) findViewById(R.id.tvSTARTButton);

	}

	@Override
	public void onClick(View v) {
		if (v.getId() == tvSetSleepTime.getId()) {
			// SET_SLEEPTIME
			timePickerDialog = TimePickerDialog.newInstance(this, 0, 0, false);
			timePickerDialog.show(getSupportFragmentManager(), "timepicker");
		} else if (v.getId() == R.id.ivPlusButton) {
			// PLUS_BUTTON -- ADD_ACTIVITY
			LayoutParams lp_NewAc = new LayoutParams(CARD_WIDTH, CARD_HEIGHT);
			lp_NewAc.weight = 1.0f;
			lp_NewAc.gravity = Gravity.CENTER_HORIZONTAL;
			inflateActivityCard(lp_NewAc);
		} else if (v.getId() == rlSTARTButton.getId()) {
			// START_BUTTON OR PAUSE_BUTTON OR RESUME_BUTTON
			//Debugging
			for (int i = 0; i < activitiesList.size(); i++) {
				Log.d("FinalActivitiesListChecking", "FALC -- name = "
						+ activitiesList.get(i).name);
				//				Log.d("FinalActivitiesListChecking", "FALC -- startTime = "
				//						+ activitiesList.get(i).getStartTime());
				//				Log.d("FinalActivitiesListChecking", "FALC -- endTime = "
				//						+ activitiesList.get(i).getEndTime());
			}
			if (tvSTARTButton.getText().toString().equals("START")) {
				// START_BUTTON
				runActivitiesTimerRecursive(activitiesList
						.get(activitiesListIndex));
				tvSTARTButton.setText("PAUSE");
				mHandler.removeCallbacks(startTimer);
			} else if (tvSTARTButton.getText().toString().equals("PAUSE")) {
				// PAUSE_BUTTON
				activitiesCDT.cancel();
				runPauseStopWatch();
				tvSTARTButton.setText("RESUME");
			} else if (tvSTARTButton.getText().toString().equals("RESUME")) {
				// RESUME_BUTTON
				mHandler.removeCallbacks(startTimer);
				int[] format = new int[3];
				formatMillis(format, elapsedTime);
				int i = activitiesListIndex;
				while (i < activitiesList.size()) {
					ActivitiesPlaan theActivitiesPlaan = activitiesList.get(i);
					if (i != activitiesListIndex) {
						theActivitiesPlaan.addStartHoursBy(format[0]);
						theActivitiesPlaan.addStartMinutesBy(format[1]);
					}
					theActivitiesPlaan.addEndHoursBy(format[0]);
					theActivitiesPlaan.addEndMinutesBy(format[1]);

					updateStartEndTimeTextViews(theActivitiesPlaan);
					i++;
				}
				CountDownTimerPlaan cdtPlaan = new CountDownTimerPlaan();
				runActivitiesTimerRecursive(activitiesList
						.get(activitiesListIndex));
				tvSTARTButton.setText("PAUSE");
			}

		}

	}

	private void updateStartEndTimeTextViews(ActivitiesPlaan theActivitiesPlaan) {
		String start = theActivitiesPlaan.getStartTime();
		String end = theActivitiesPlaan.getEndTime();
		theActivitiesPlaan.getActivityCard().tvStartEndCD.setText(start + " - "
				+ end);
	}

	private Runnable startTimer = new Runnable() {
		public void run() {
			elapsedTime = System.currentTimeMillis() - startTime;
			int[] format = new int[3];
			formatMillis(format, elapsedTime);
			activityCardOnFocus.setTvCountDownText(addZeros("" + format[0])
					+ ":" + addZeros("" + format[1]) + ":"
					+ addZeros("" + format[2]));
			mHandler.postDelayed(this, REFRESH_RATE);
		}
	};

	private void runPauseStopWatch() {
		startTime = System.currentTimeMillis();
		mHandler.removeCallbacks(startTimer);
		mHandler.postDelayed(startTimer, 0);
	}

	private void runActivitiesTimerRecursive(ActivitiesPlaan theActivities) {
		if (activitiesCDT != null)
			activitiesCDT.cancel();

		long time = theActivities.interval;
		activityCardOnFocus = theActivities.getActivityCard();
		Log.d("time long error", "TLE -- time = " + time);
		if (theActivities.getType() == ActivitiesPlaan.TYPE_LOOPING) {
			// set looping layout
			// break or looping
			if (theActivities.getCurrentState() == ActivitiesPlaan.LOOPING_STATE) {
				activityCardOnFocus.setTvBreakVisibility(View.INVISIBLE);
				time = theActivities.loopTime();
			} else if (theActivities.getCurrentState() == ActivitiesPlaan.BREAK_STATE) {
				activityCardOnFocus.setTvBreakVisibility(View.VISIBLE);
				time = theActivities.breakTime();
			}
		}

		// run the actual timer
		activitiesCDT = new CountDownTimer(time, 1000) {
			public void onTick(long millisUntilFinished) {
				// declare activitiesPlaan
				ActivitiesPlaan theActivities = activityCardOnFocus
						.getActivitiesPlaan();

				// formatMillis to be like hh:mm:ss
				int[] format = new int[3];
				formatMillis(format, millisUntilFinished);
				String s = "";
				if (format[0] != 0)
					s += addZeros("" + format[0]) + ":";
				if (format[0] != 0 || format[1] != 0)
					s += addZeros("" + format[1]) + ":";
				s += addZeros("" + format[2]);
				activityCardOnFocus.setTvCountDownText(s);

				// update interval / looptime / breaktime
				if (theActivities.getType() == ActivitiesPlaan.TYPE_ONE_TIME)
					theActivities.setInterval(millisUntilFinished);
				else if (theActivities.getType() == ActivitiesPlaan.TYPE_LOOPING) {
					if (theActivities.getState() == ActivitiesPlaan.BREAK_STATE) {
						theActivities.breakTime = millisUntilFinished;
					} else {
						theActivities.loopTime = millisUntilFinished;
					}
				}
			}

			private String addZeros(String s) {
				if (s.length() == 1) {
					s = "0" + s;
				}
				return s;
			}

			public void onFinish() {
				ActivitiesPlaan theActivies = activitiesList
						.get(activitiesListIndex);
				String body = "";
				String title = "";

				if (theActivies.type == ActivitiesPlaan.TYPE_LOOPING
						&& theActivies.getLoopLeft() != 0) {
					// incumbent running activity is TYPE_LOOPING

					// reset LoopTime and BreakTime
					theActivies.resetLoopTime();
					theActivies.resetBreakTime();

					if (theActivies.getCurrentState() == ActivitiesPlaan.BREAK_STATE) {
						theActivies.decreaseLoops();
						// notif run the next loop
						body = "Do " + theActivies.name + ",for "
								+ theActivies.loopTime + " Minutes";
						title = theActivies.name + " started";
						int loopingFreq = Integer.parseInt(theActivies
								.getActivityCard().tvLoopingFreqCD.getText()
								.toString());
						theActivies.getActivityCard().tvLoopingFreqCD
								.setText("" + (loopingFreq - 1));
						showNotification(body, title);

					} else {
						// notif run the break
						body = "Break for " + theActivies.breakTime
								+ " Minutes";
						title = "Break Time Started";
						showNotification(body, title);
					}
					theActivies.alterState(theActivies.getCurrentState());
					runActivitiesTimerRecursive(theActivies);

				} else {
					// go to the next activity in the list
					markFinishedActivity(theActivies);
					activitiesListIndex++;
					if (activitiesListIndex < activitiesList.size()) {
						// (if) checking wether continue to recurse
						theActivies = activitiesList.get(activitiesListIndex);
						body = "Do " + theActivies.name + ",for "
								+ theActivies.interval + " Minutes";
						title = theActivies.name + " started";
						showNotification(body, title);
						runActivitiesTimerRecursive(activitiesList
								.get(activitiesListIndex));
					}
				}
			}

			private void markFinishedActivity(ActivitiesPlaan theActivies) {
				ActivityCard finishedCard = theActivies.getActivityCard();
				finishedCard.llRootActivityCard.setAlpha(0.5f);
				if (!finishedCard.getActivitiesPlaan().name.equals("Free Time")) {
					finishedCard.tvCountDown.setVisibility(View.GONE);
					finishedCard.tvDONE.setVisibility(View.VISIBLE);
				}
			}

			private void showNotification(String body, String title) {
				Intent intent = new Intent(ScrollingUI.this, ScrollingUI.class);
				PendingIntent pi = PendingIntent.getActivity(
						getApplicationContext(), 0, intent, 0);
				Notification n = new Notification(R.drawable.plaan_icon2, body,
						System.currentTimeMillis());
				n.setLatestEventInfo(getApplicationContext(), title, body, pi);
				n.defaults = Notification.DEFAULT_ALL;
				nm.notify(notificationId, n);
			}
		};
		activitiesCDT.start();
	}

	private void formatMillis(int[] format, long millisUntilFinished) {
		// format[0] = hours, format[1] = minutes , format[2] = seconds
		format[0] = (int) ((millisUntilFinished / (1000 * 60 * 60)) % 24);
		format[1] = (int) ((millisUntilFinished / (1000 * 60)) % 60);
		format[2] = (int) (millisUntilFinished / 1000) % 60;
	}

	@Override
	public void onTimeSet(RadialPickerLayout v, int hourOfDay, int minute) {

		tvSetSleepTime.setText(addZeros("" + hourOfDay) + ":"
				+ addZeros("" + minute));

		// timeRemaining is in minutes
		// timeRemaining = calculateTimeRemaining(hourOfDay, minute);

		// inflate the activityCard
		LayoutParams lp_ActivityCard = new LayoutParams(CARD_WIDTH, CARD_HEIGHT);
		lp_ActivityCard.weight = 1.0f;
		lp_ActivityCard.gravity = Gravity.CENTER_HORIZONTAL;
		lp_ActivityCard.setMargins(0, (int) (10 * scaleDP + 0.5f), 0, 0);
		inflateActivityCard(lp_ActivityCard);

		ivPlusButton.setVisibility(View.VISIBLE);
		rlSTARTButton.setVisibility(View.VISIBLE);

	}

	private void inflateActivityCard(LayoutParams params) {
		// Initalize(inflate) the ActivityCard
		ActivityCard theCard = null;
		if (LAYOUT_POSITION - 1 >= 0) {
			// If the card above is exist
			// To access previous activities endTime
			// And set it to theCard startTime
			ActivityCard aboveTheCard = (ActivityCard) llLayoutActivityCard
					.getChildAt(LAYOUT_POSITION - 1);
			ActivitiesPlaan aboveActivitiesPlaan = aboveTheCard
					.getActivitiesPlaan();
			theCard = new ActivityCard(this, getSupportFragmentManager(),
					getLayoutInflater(), Integer.parseInt("" + TAG_HEADER
							+ tag_counter), svScrollingUI,
					aboveActivitiesPlaan.getEndTime());
		} else {
			// If there is no card above
			theCard = new ActivityCard(this, getSupportFragmentManager(),
					getLayoutInflater(), Integer.parseInt("" + TAG_HEADER
							+ tag_counter), svScrollingUI);
		}

		tag_counter++;
		theCard.setId(Integer.parseInt("" + AC_ID_HEADER + acIDCounter));
		activityCardList.add(theCard);

		// Animation for theCard
		Animation comeIn = AnimationUtils.loadAnimation(
				getApplicationContext(), R.anim.down_from_top_w_alpha);
		comeIn.setFillAfter(true);
		theCard.setAnimation(comeIn);

		// Add theCard(UNSET) TO llActivityCard(just above sleepingCard)
		// debugging
		Log.d("Adding new card error",
				"ANCE -- BEFORE llLayoutActivityCard.indexOfChild(rlSleepingCard)  = "
						+ llLayoutActivityCard
								.indexOfChild(rlLayoutSleepingCard));
		llLayoutActivityCard
				.addView(
						theCard,
						llLayoutActivityCard.indexOfChild(rlLayoutSleepingCard),
						params);
		Log.d("Adding new card error",
				"ANCE -- AFTER llLayoutActivityCard.indexOfChild(rlSleepingCard) = "
						+ llLayoutActivityCard
								.indexOfChild(rlLayoutSleepingCard));

		// If the card below is exist
		if (LAYOUT_POSITION + 1 < llLayoutActivityCard.getChildCount()) {
			// Animation for BELOW theCard
			Animation comeInWoAlpha = AnimationUtils.loadAnimation(
					getApplicationContext(), R.anim.down_from_top_wt_alpha);
			View belowTheCard = llLayoutActivityCard
					.getChildAt(LAYOUT_POSITION + 1);
			belowTheCard.setAnimation(comeInWoAlpha);
		}

		// listen for a SET click
		theCard.setOnSetClickListener(new onSetClickListener() {
			@Override
			public void onSetClick(ActivitiesPlaan theActivity,
					boolean firstTimeVisit, ActivityCard theCard) {
				if (LAYOUT_POSITION - 1 >= 0) {
					// if the card above is already exist
					ActivityCard aboveCard = (ActivityCard) llLayoutActivityCard
							.getChildAt(activitiesList.size() - 1);

					String aboveEndTime = aboveCard.getActivitiesPlaan()
							.getEndTime();
					String theActivityStartTime = theActivity.getStartTime();

					int aboveEndTimeINT = Integer.parseInt(aboveEndTime
							.substring(0, 2) + aboveEndTime.substring(3));
					int theActivityStartTimeINT = Integer
							.parseInt(theActivityStartTime.substring(0, 2)
									+ theActivityStartTime.substring(3));

					if (theActivityStartTimeINT - aboveEndTimeINT >= 0) {
						// debugging
						Log.d("FreeTime error 2", "FTE2 -- NOT use FREE_TIME");
						// Will add to the last activity just before sleep
						// No need to break through FreeTimeCards
						if (!activitiesList.contains(theActivity)) {
							// if its new activity
							activitiesList.add(theActivity);
							// // timeRemaining = millisLeft;
							if (activitiesList.size() - 2 >= 0) {

								setUpFreTimeCard(activitiesList
										.get(activitiesList.size() - 2),
										activitiesList.getLast(),
										activitiesList.size() - 1);
							}
							LAYOUT_POSITION++;
						} else {
							// if its an old activity
							// will update it's activity information
							int i = activitiesList.indexOf(theActivity);
							activitiesList.set(i, theActivity);
						}
					} else {
						Log.d("FreeTime error 2", "FTE2 -- use FREE_TIME");
						// if the activity is use up freeTime
						int acListIndex = 0;
						boolean found = false;

						// loop through freeTimeCard
						while (!found && acListIndex < activitiesList.size()) {
							ActivitiesPlaan theFreeTimeActivities = activitiesList
									.get(acListIndex);
							if (theFreeTimeActivities.name.equals("Free Time")) {
								FreeTimeCard theFreeTimeCard = (FreeTimeCard) theFreeTimeActivities
										.getActivityCard();
								if (calculateTimeDifference(
										theFreeTimeActivities.getStartTime(),
										theActivity.getStartTime()) <= 0) {
									// if theActivity.startTime is after freeTime startTime
									if (calculateTimeDifference(
											theFreeTimeActivities.getEndTime(),
											theActivity.getEndTime()) >= 0) {
										// if theActivity.startTime is before freeTime.endTime
										// It's possible to break the current freeTime

										// Change the current freeTimeCard info
										found = true;
										theFreeTimeActivities.setInterval(
												theFreeTimeActivities
														.getStartTime(),
												theActivity.getStartTime());
										long timeDuration = theFreeTimeActivities
												.getInterval() * 60000;
										theFreeTimeCard.setFreeTimeCardTextViews(
												theFreeTimeActivities
														.getStartTime(),
												theActivity.getStartTime(),
												timeDuration);

										// add new activity
										llLayoutActivityCard
												.removeView(theCard);
										int indexOfFtc = llLayoutActivityCard
												.indexOfChild(theFreeTimeCard);
										llLayoutActivityCard.addView(theCard,
												indexOfFtc + 1);
										activitiesList.add(acListIndex + 1,
												theActivity);
										// add new freeTime, if neccesary
										ActivityCard otherCard = (ActivityCard) llLayoutActivityCard
												.getChildAt(indexOfFtc + 2);
										setUpFreTimeCard(
												theCard.getActivitiesPlaan(),
												otherCard.getActivitiesPlaan(),
												acListIndex + 2);
									}

								}
							}

							acListIndex++;
						}

					}
				} else {
					// if its the first activity.
					// It's always gonna be the first activity
					activitiesList.add(theActivity);
					LAYOUT_POSITION++;
				}
			}

			private int calculateTimeDifference(String time1, String time2) {
				int startTimeINT = Integer.parseInt(time1.substring(0, 2)
						+ time1.substring(3));
				int startTime2INT = Integer.parseInt(time2.substring(0, 2)
						+ time2.substring(3));
				return startTimeINT - startTime2INT;
			}

			private void setUpFreTimeCard(ActivitiesPlaan activityAbove,
					ActivitiesPlaan currentActivity, int posOnActivitiesList) {
				// ActivitiesList lastIndex
				int lastIndex = activitiesList.size() - 1;

				// Inflate freeTimeCard if neccesary
				if (lastIndex > 0 // make sure sleepcard is instantiated
						&& !activityAbove.getEndTime().equals(
								currentActivity.getStartTime())) {
					// Inflate the freeTimeCard
					LayoutParams ftcParams = new LayoutParams(CARD_WIDTH,
							CARD_HEIGHT);
					ftcParams.weight = 1.0f;
					ftcParams.gravity = Gravity.CENTER_HORIZONTAL;
					ftcParams.setMargins(0, (int) (10 * scaleDP + 0.5f), 0, 0);
					FreeTimeCard ftc = inflateFreeTimeCard(currentActivity,
							ftcParams, activityAbove.getEndTime(),
							currentActivity.getStartTime());

					// Setting freeTime activity
					activitiesList.add(posOnActivitiesList,
							ftc.getActivitiesPlaan());
				}
			}

		});
		acIDCounter++;

	}

	private FreeTimeCard inflateFreeTimeCard(ActivitiesPlaan currentActivity,
			LayoutParams ftcParams, String startTime, String endTime) {
		// Constructor also make theActivitiesPlaan of freeTimeCard
		FreeTimeCard ftc = new FreeTimeCard(getApplicationContext(), startTime,
				endTime);
		Animation comeIn = AnimationUtils.loadAnimation(
				getApplicationContext(), R.anim.down_from_top_w_alpha);
		ftc.setAnimation(comeIn);
		int ftc_LAYOUT_POSITION = llLayoutActivityCard
				.indexOfChild(currentActivity.getActivityCard());
		llLayoutActivityCard.addView(ftc, ftc_LAYOUT_POSITION, ftcParams);
		ftc.setId(Integer.parseInt(FTC_ID_HEADER + "" + ftc_id_counter));
		ftc_id_counter++;
		// If the card below is exist
		if (ftc_LAYOUT_POSITION + 1 < llLayoutActivityCard.getChildCount()) {
			// Animation for BELOW theCard
			Animation comeInWoAlpha = AnimationUtils.loadAnimation(
					getApplicationContext(), R.anim.down_from_top_wt_alpha);
			View belowTheCard = llLayoutActivityCard
					.getChildAt(LAYOUT_POSITION + 1);
			belowTheCard.setAnimation(comeInWoAlpha);

		}

		LAYOUT_POSITION++;
		ftcList.add(ftc);

		return ftc;
	}

	// return timeRemaining in minutes form
	private int calculateTimeRemaining(int userHours, int userMinutes) {
		Calendar c = Calendar.getInstance();

		int systemHours = c.get(Calendar.HOUR_OF_DAY);
		int systemMinutes = c.get(Calendar.MINUTE);

		int hoursDifference = userHours - systemHours;
		int minutesDifference = userMinutes - systemMinutes;
		int timeRemaining = hoursDifference * 60 + minutesDifference;

		if (timeRemaining <= 0) {
			hoursDifference = (userHours + 24) - systemHours;
			timeRemaining = hoursDifference * 60 + minutesDifference;
		}

		return timeRemaining * 60000;
	}

	private String addZeros(String s) {
		if (s.length() == 1) {
			s = "0" + s;
		}
		return s;
	}

	@Override
	public void onBackPressed() {
		Intent backtoHome = new Intent(Intent.ACTION_MAIN);
		backtoHome.addCategory(Intent.CATEGORY_HOME);
		backtoHome.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
		startActivity(backtoHome);
	}

}
