package com.example.plaan;

import java.util.Calendar;
import java.util.LinkedList;

import android.app.Notification;
import android.app.PendingIntent;
import android.content.Intent;
import android.os.Bundle;
import android.os.CountDownTimer;
import android.support.v4.app.FragmentActivity;
import android.view.Gravity;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.Window;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.LinearLayout.LayoutParams;
import android.widget.RelativeLayout;
import android.widget.TextView;

import com.example.plaan.ActivityCard.onSetClickListener;
import com.zenkun.datetimepicker.time.RadialPickerLayout;
import com.zenkun.datetimepicker.time.TimePickerDialog;
import com.zenkun.datetimepicker.time.TimePickerDialog.OnTimeSetListener;

public class ScrollingUI extends FragmentActivity implements OnClickListener,
		OnTimeSetListener {

	private int CARD_WIDTH;
	private int CARD_HEIGHT;

	// SleepingCard
	LinearLayout llLayoutActivityCard;
	RelativeLayout rlLayoutSleepingCard, rlAvailableTimeClock, rlSleepingCard,
			rlSleepingCloudGroup, rlYellowClock;
	ImageView ivAvailableTimeClock, ivBlueTimeFrame, ivSleepingCloud;
	TextView tvAvailableTime, tvSLEEP, tvSetSleepTime;

	// ActivityCard
	final int AC_ID_HEADER = 224;
	int acIDCounter;
	LinkedList<ActivitiesPlaan> activitiesList;
	LinkedList<ActivityCard> activityCardList;
	int activitiesListIndex;
	int LAYOUT_POSITION;

	// plus_button
	ImageView ivPlusButton;

	// start_button
	RelativeLayout rlSTARTButton;
	TextView tvSTARTButton;

	int clickedActivityType;
	public static TimePickerDialog timePickerDialog;

	float scaleDP;

	// long timeRemaining;

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		this.requestWindowFeature(Window.FEATURE_NO_TITLE);
		super.onCreate(savedInstanceState);
		setContentView(R.layout.scrolling_ui_main);

		scaleDP = getApplicationContext().getResources().getDisplayMetrics().density;
		CARD_WIDTH = (int) (300 * scaleDP + 0.5f);
		CARD_HEIGHT = (int) (375 * scaleDP + 0.5f);
		acIDCounter = 0;
		activitiesList = new LinkedList<>();
		activityCardList = new LinkedList<>();
		LAYOUT_POSITION = 0;

		activitiesListIndex = 0;

		initializeViews();
		setTypefaces();

		// sleepCard
		tvSetSleepTime.setOnClickListener(this);

		// plusButton
		ivPlusButton.setOnClickListener(this);

		// startButton
		rlSTARTButton.setOnClickListener(this);

	}

	private void setTypefaces() {
		TypefacePlaan tfp = new TypefacePlaan();
		tfp.setTypeface(tvAvailableTime, TypefacePlaan.LEAGUE_GOTHIC);
		tfp.setTypeface(tvSLEEP, TypefacePlaan.OPEN_SANS_BOLD);
		tfp.setTypeface(tvSetSleepTime, TypefacePlaan.OPEN_SANS_BOLD);
		tfp.setTypeface(tvSTARTButton, TypefacePlaan.LEAGUE_GOTHIC);
	}

	private void initializeViews() {
		// SleepingCard
		llLayoutActivityCard = (LinearLayout) findViewById(R.id.llLayoutActivityCard);
		rlLayoutSleepingCard = (RelativeLayout) findViewById(R.id.rlLayoutSleepingCard);
		rlSleepingCard = (RelativeLayout) findViewById(R.id.rlSleepingCard);
		rlSleepingCloudGroup = (RelativeLayout) findViewById(R.id.rlSleepingCloudGroup);

		ivSleepingCloud = (ImageView) findViewById(R.id.ivSleepingCloud);
		tvSLEEP = (TextView) findViewById(R.id.tvSLEEP);
		tvSetSleepTime = (TextView) findViewById(R.id.tvSetSleepTime);
		tvAvailableTime = (TextView) findViewById(R.id.tvAvailableTime);

		// plusButton
		ivPlusButton = (ImageView) findViewById(R.id.ivPlusButton);

		// startButton
		rlSTARTButton = (RelativeLayout) findViewById(R.id.rlStartButton);
		tvSTARTButton = (TextView) findViewById(R.id.tvSTARTButton);

	}

	@Override
	public void onClick(View v) {
		if (v.getId() == tvSetSleepTime.getId()) {
			timePickerDialog = TimePickerDialog.newInstance(this, 0, 0, false);
			timePickerDialog.show(getSupportFragmentManager(), "timepicker");
		} else if (v.getId() == R.id.ivPlusButton) {
			LayoutParams lp_NewAc = new LayoutParams(CARD_WIDTH, CARD_HEIGHT);
			lp_NewAc.weight = 1.0f;
			lp_NewAc.gravity = Gravity.CENTER_HORIZONTAL;
			inflateActivityCard(lp_NewAc);
		} else if (v.getId() == rlSTARTButton.getId()) {
			runActivitiesTimerRecursive(activitiesList.get(activitiesListIndex));
		}

	}

	private void runActivitiesTimerRecursive(ActivitiesPlaan theActivities) {
		int time = theActivities.interval;
		ActivityCard theActivityCard = theActivities.getActivityCard();
		if (theActivities.getType() == ActivitiesPlaan.TYPE_LOOPING) {
			// set looping layout
			theActivityCard.decreaseLoopLeft();
			// break or looping
			if (theActivities.getCurrentState() == ActivitiesPlaan.LOOPING_STATE) {
				theActivityCard.setTvBreakVisibility(View.INVISIBLE);
				time = theActivities.loopTime();
			} else if (theActivities.getCurrentState() == ActivitiesPlaan.BREAK_STATE) {
				theActivityCard.setTvBreakVisibility(View.VISIBLE);
				time = theActivities.breakTime();
			}
		}

		// run the actual timer
		new CountDownTimer(time * 60000, 1000) {
			public void onTick(long millisUntilFinished) {
				
				theActivityCard.tvCountDown.setText(""
						+ addZeros("" + ((millisUntilFinished / 1000) / 60))
						+ ":"
						+ addZeros("" + ((millisUntilFinished / 1000)) % 60));
			}

			private String addZeros(String s) {
				if (s.length() == 1) {
					s = "0" + s;
				}
				return s;
			}

			public void onFinish() {
				ActivitiesPlaan theActivies = activitiesList
						.get(activitiesListIndex);
				String body = "";
				String title = "";

				if (theActivies.type == ActivitiesPlaan.TYPE_LOOPING
						&& theActivies.getLoopLeft() != 0) {
					// incumbent running activity is TYPE_LOOPING
					if (theActivies.getCurrentState() == ActivitiesPlaan.BREAK_STATE) {
						theActivies.decreaseLoops();
						// run the activty
						body = "Do " + theActivies.name + ",for "
								+ theActivies.loopTime + " Minutes";
						title = theActivies.name + " started";
						showNotification(body, title);

					} else {
						// run the break
						body = "Break for " + theActivies.breakTime
								+ " Minutes";
						title = "Break Time Started";
						showNotification(body, title);
					}
					theActivies.alterState(theActivies.getCurrentState());
					runActivitiesTimerRecursive(theActivies);

				} else {
					// go to the next activity in the list
					activitiesListIndex++;
					theActivies = activitiesList.get(activitiesListIndex);
					if (activitiesListIndex < activitiesList.size()) {
						// checking wether continue to recurse
						body = "Do " + theActivies.name + ",for "
								+ theActivies.interval + " Minutes";
						title = theActivies.name + " started";
						showNotification(body, title);
						runActivitiesTimerRecursive(activitiesList
								.get(activitiesListIndex));
					}
				}
			}

			private void showNotification(String body, String title) {
				Intent intent = new Intent("com.example.plaan.ACDP");
				PendingIntent pi = PendingIntent.getActivity(
						getApplicationContext(), 0, intent, 0);
				Notification n = new Notification(R.drawable.plaan_icon2, body,
						System.currentTimeMillis());
				n.setLatestEventInfo(getApplicationContext(), title, body, pi);
				n.defaults = Notification.DEFAULT_ALL;
				nm.notify(notificationId, n);
			}
		}.start();
	}

	@Override
	public void onTimeSet(RadialPickerLayout v, int hourOfDay, int minute) {

		tvSetSleepTime.setText(addZeros("" + hourOfDay) + ":"
				+ addZeros("" + minute));

		// timeRemaining is in minutes
		// timeRemaining = calculateTimeRemaining(hourOfDay, minute);

		// inflate the activityCard
		LayoutParams lp_ActivityCard = new LayoutParams(CARD_WIDTH, CARD_HEIGHT);
		lp_ActivityCard.weight = 1.0f;
		lp_ActivityCard.gravity = Gravity.CENTER_HORIZONTAL;
		lp_ActivityCard.setMargins(0, (int) (10 * scaleDP + 0.5f), 0, 0);
		inflateActivityCard(lp_ActivityCard);

	}

	private void inflateActivityCard(LayoutParams params) {
		ActivityCard theCard = new ActivityCard(this,
				getSupportFragmentManager(), getLayoutInflater());
		theCard.setId(Integer.parseInt("" + AC_ID_HEADER + acIDCounter));
		activityCardList.add(theCard);
		llLayoutActivityCard.addView(theCard, LAYOUT_POSITION, params);
		LAYOUT_POSITION++;
		theCard.setOnSetClickListener(new onSetClickListener() {

			@Override
			public void onSetClick(ActivitiesPlaan theActivity,
					boolean firstTimeVisit) {

				if (!activitiesList.contains(theActivity))
					activitiesList.add(theActivity);
				else {
					int i = activitiesList.indexOf(theActivity);
					activitiesList.set(i, theActivity);
				}
				// timeRemaining = millisLeft;
				if (firstTimeVisit) {
					int lastIndex = activitiesList.size() - 1;
					// inflate freeTimeCard if neccesary
					if (lastIndex > 0
							&& !theActivity.getStartTime().equals(
									activitiesList.get(lastIndex - 1)
											.getEndTime())) {
						LayoutParams ftcParams = new LayoutParams(CARD_WIDTH,
								CARD_HEIGHT);
						ftcParams.weight = 1.0f;
						ftcParams.gravity = Gravity.CENTER_HORIZONTAL;
						ftcParams.setMargins(0, (int) (10 * scaleDP + 0.5f), 0,
								0);
						inflateFreeTimeCard(ftcParams,
								activitiesList.get(lastIndex - 1).getEndTime(),
								activitiesList.get(lastIndex).getStartTime());
					}

				}
			}

		});
		acIDCounter++;

	}

	private void inflateFreeTimeCard(LayoutParams ftcParams, String startTime,
			String endTime) {
		FreeTimeCard ftc = new FreeTimeCard(getApplicationContext(), startTime,
				endTime);
		llLayoutActivityCard.addView(ftc, LAYOUT_POSITION - 1, ftcParams);
		LAYOUT_POSITION++;
	}

	// return timeRemaining in minutes form
	private int calculateTimeRemaining(int userHours, int userMinutes) {
		Calendar c = Calendar.getInstance();

		int systemHours = c.get(Calendar.HOUR_OF_DAY);
		int systemMinutes = c.get(Calendar.MINUTE);

		int hoursDifference = userHours - systemHours;
		int minutesDifference = userMinutes - systemMinutes;
		int timeRemaining = hoursDifference * 60 + minutesDifference;

		if (timeRemaining <= 0) {
			hoursDifference = (userHours + 24) - systemHours;
			timeRemaining = hoursDifference * 60 + minutesDifference;
		}

		return timeRemaining * 60000;
	}

	private String addZeros(String s) {
		if (s.length() == 1) {
			s = "0" + s;
		}
		return s;
	}

}
