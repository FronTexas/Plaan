package com.example.plaan;

import android.os.Parcel;
import android.os.Parcelable;

public class ActivitiesPlaan implements Parcelable {
	public static int TYPE_NONE = -1;
	public static int TYPE_ONE_TIME = 1;
	public static int TYPE_LOOPING = 2;
	final int MERIDIEM_ADJUSTMENT = 1200;
	final int ONE_HOUR = 60;
	public final static int LOOPTYPE_MINUTE = 1;
	public final static int LOOPTYPE_HOUR = 2;

	public static int BREAK_STATE = 7;
	public static int LOOPING_STATE = 8;

	String name;
	int type;
	ActivityCard activityCard;

	int startHours;
	int startMinutes;

	int endHours;
	int endMinutes;

	int loops;
	int loopTime;
	int loopTimeType;
	int breakTime;
	int breakType;
	int interval;

	int id;

	int state;

	public static final Parcelable.Creator<ActivitiesPlaan> CREATOR = new Parcelable.Creator<ActivitiesPlaan>() {
		public ActivitiesPlaan createFromParcel(Parcel in) {
			return new ActivitiesPlaan(in);
		}

		public ActivitiesPlaan[] newArray(int size) {
			return new ActivitiesPlaan[size];
		}
	};

	// example constructor that takes a Parcel and gives you an object populated
	// with it's values
	private ActivitiesPlaan(Parcel in) {
		name = in.readString();
		type = in.readInt();
		startHours = in.readInt();
		startMinutes = in.readInt();
		endHours = in.readInt();
		endMinutes = in.readInt();
		loops = in.readInt();
		loopTime = in.readInt();
		loopTimeType = in.readInt();
		breakTime = in.readInt();
		breakType = in.readInt();
		interval = in.readInt();
		state = in.readInt();
		id = in.readInt();
	}

	public ActivitiesPlaan(String name, int type) {
		this.name = name;
		this.type = type;
		startHours = -1;
		startMinutes = -1;
		endHours = -1;
		endMinutes = -1;
		loops = -1;
		loopTime = -1;
		loopTimeType = -1;
		breakTime = -1;
		breakType = -1;
		breakType = -1;
		state = LOOPING_STATE;
		this.interval = 0;
		id = 0;
	}

	public ActivitiesPlaan(String name) {
		this.name = name;
		startHours = -1;
		startMinutes = -1;
		endHours = -1;
		endMinutes = -1;
		loops = -1;
		loopTime = -1;
		loopTimeType = -1;
		breakTime = -1;
		breakType = -1;
		breakType = -1;
		state = LOOPING_STATE;
		this.interval = 0;
		id = 0;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getId() {
		return id;
	}

	public void setActivityCard(ActivityCard activityCard) {
		this.activityCard = activityCard;
	}

	public ActivityCard getActivityCard() {
		return activityCard;
	}

	public int getActivityCardId() {
		return activityCard.getId();
	}

	public void setType(int type) {
		this.type = type;

	}

	public String getTypeString() {
		if (type == TYPE_ONE_TIME)
			return "One Time";
		else
			return "Looping";
	}

	public int getType() {
		return type;
	}

	public int getCurrentState() {
		return state;
	}

	/**
	 * * PRE : type == ONE_TIME
	 * 
	 * @param start
	 *            = the start time in the form of xxxxAM or xxxxPM
	 * @param end
	 *            = the end time in the form of xxxxAM or xxxxPM * POST :
	 *            startTime,endTime,and interval are set.
	 */
	public void setInterval(int startHours, int startMinutes, int endHours,
			int endMinutes, String startMeridiem, String endMeridiem) {
		if (this.type == TYPE_ONE_TIME) {
			this.startHours = startHours;
			this.startMinutes = startMinutes;

			this.endHours = endHours;
			this.endMinutes = endMinutes;

			int hoursInterval = endHours - startHours;
			int minutesInterval = endMinutes - startMinutes;

			this.interval = (hoursInterval * 60) + minutesInterval; // in
			if (interval <= 0) {
				int endHoursAdjusted = endHours + 24;
				hoursInterval = endHoursAdjusted - startHours;
				interval = (hoursInterval * 60) + minutesInterval;
			}
		} else if (this.type == TYPE_LOOPING) {
			throw new IllegalArgumentException(
					"setInterval pre-condition not met. type is not ONE_TIME");
		}
	}

	/**
	 * * PRE : type == ONE_TIME
	 * 
	 * @param start
	 *            = the start time in the form of xxxxAM or xxxxPM
	 * @param end
	 *            = the end time in the form of xxxxAM or xxxxPM * POST :
	 *            startTime,endTime,and interval are set.
	 */
	public void setInterval(String startTime, String endTime) {
		int startHours = Integer.parseInt(startTime.substring(0, 2));
		int startMinutes = Integer.parseInt(startTime.substring(3));
		int endHours = Integer.parseInt(endTime.substring(0, 2));
		int endMinutes = Integer.parseInt(endTime.substring(3));

		if (this.type == TYPE_ONE_TIME) {
			this.startHours = startHours;
			this.startMinutes = startMinutes;

			this.endHours = endHours;
			this.endMinutes = endMinutes;

			int hoursInterval = endHours - startHours;
			int minutesInterval = endMinutes - startMinutes;

			this.interval = (hoursInterval * 60) + minutesInterval; // in
			if (interval <= 0) {
				int endHoursAdjusted = endHours + 24;
				hoursInterval = endHoursAdjusted - startHours;
				interval = (hoursInterval * 60) + minutesInterval;
			}
		} else if (this.type == TYPE_LOOPING) {
			throw new IllegalArgumentException(
					"setInterval pre-condition not met. type is not ONE_TIME");
		}
	}

	/**
	 * * PRE : type == TYPE_REPETITIVE
	 * 
	 * @param start
	 *            = the start time in the form of xxxxAM or xxxxPM
	 */
	public void setInterval(int startHours, int startMinutes, int loops,
			int loopTime, int loopType, int breakTime, int breakTimeType) {
		if (this.type == TYPE_LOOPING) {
			this.startHours = startHours;
			this.startMinutes = startMinutes;
			this.loops = loops;
			this.loopTime = loopTime;
			this.loopTimeType = loopType;
			this.breakTime = breakTime;
			this.breakType = breakTimeType;

			switch (loopType) {
			case LOOPTYPE_MINUTE:
				interval = loops * (loopTime + breakTime); // time is in minutes
				break;
			case LOOPTYPE_HOUR:
				interval = loops * (loopTime * 60 + breakTime); // time is in
				break;
			}

			int[] endHours = new int[1];
			int[] endMinutes = new int[1];
			int[] hoursIncreased = new int[1];
			endHours[0] = startHours + interval / 60;
			endMinutes[0] = startMinutes + interval % 60;

			checkForMoreThan(endMinutes, 60, hoursIncreased);
			endHours[0] += hoursIncreased[0];
			checkForMoreThan(endHours, 24, hoursIncreased);

		} else if (this.type == TYPE_ONE_TIME) {
			throw new IllegalArgumentException(
					"setInterval pre-condition not met. type is not REPETITIVE");
		}
	}

	private void checkForMoreThan(int[] time, int usualNumber,
			int[] hoursIncreased) {
		while (time[0] >= usualNumber) {
			time[0] -= usualNumber;
			hoursIncreased[0]++;
		}
	}

	public int getInterval() {
		// return (this.interval % 100) + (this.interval / 100) * ONE_HOUR;
		return interval;

	}

	public String getStartTime() {
		String startTime = addZeros("" + startHours) + ":"
				+ addZeros("" + startMinutes);
		return startTime;
	}

	public String getEndTime() {
		String endTime = addZeros("" + endHours) + ":"
				+ addZeros("" + endMinutes);
		return endTime;
	}

	public String getStartHours() {
		return addZeros("" + startHours);
	}

	public String getStartMinutes() {
		return addZeros("" + startMinutes);
	}

	public String getEndHours() {
		return addZeros("" + endHours);
	}

	public String getEndMinutes() {
		return addZeros("" + endMinutes);
	}

	public void decreaseLoops() {
		loops--;
	}

	public int getLoopLeft() {
		return loops;
	}

	public int loops() {
		return loops;
	}

	public int loopTime() {
		return loopTime;
	}

	public int breakTime() {
		return breakTime;
	}

	public void alterState(int previousState) {
		if (previousState == LOOPING_STATE)
			state = BREAK_STATE;
		else
			state = LOOPING_STATE;
	}

	private String addZeros(String s) {
		if (s.length() == 1) {
			s = "0" + s;
		}
		return s;
	}

	@Override
	public String toString() {
		return this.name;
	}

	@Override
	public int describeContents() {
		return 0;
	}

	@Override
	public void writeToParcel(Parcel out, int flags) {
		out.writeString(name);
		out.writeInt(type);
		out.writeInt(startHours);
		out.writeInt(startMinutes);
		out.writeInt(endHours);
		out.writeInt(endMinutes);
		out.writeInt(loops);
		out.writeInt(loopTime);
		out.writeInt(loopTimeType);
		out.writeInt(breakTime);
		out.writeInt(breakType);
		out.writeInt(interval);
		out.writeInt(state);
		out.writeInt(id);
	}

	@Override
	public boolean equals(Object o) {
		ActivitiesPlaan otherActivites = (ActivitiesPlaan) o;
		return otherActivites.getActivityCard().getTag() == this
				.getActivityCard().getTag();
	}
}
